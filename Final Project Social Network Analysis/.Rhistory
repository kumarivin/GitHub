x<-1:20
x
x<-list(1,'a',TRUE,1+4i)
print(x)
dim(x1)<-c(2,5)
x1<-1:20
dim(x1)<-c(2,5)
dim(x1)<-c(4,5)
print(x1)
x<-factor(c('yes','no,'yes','yes','no'))
x<- factor(c('yes','no,'yes','yes','no'))
x<-factor(c('yes','no','yes','yes','no'))
x
table(x)
unclass(x)
x<-factor(c('yes','no','yes','yes','no'),levels=c('yes','no'))
x
x<-data.frame(foo=1:4,bar=c(T,T,F,F))
x
x=10
x
as.logical(x)
q()
x<-c('a','b','c','c','d','a')
x
u<-x>'a'
u
x(u)
x[u]
x=list(foo=1:4,bar=0.6,baz="hello")
x[c(1,3)]
x<-list(aardvark=1:5)
x
x$a
x<-list(aardvark=1:5,ardnak=6:10)
x$a
x[['a',exact=false]]
x[['a',exact=FALSE]]
x<-list(aardvark=1:5)
x[['a',exact=FALSE]]
x<-(1,2,NA,3,NA,5,NA)
x<-c(1,2,NA,3,NA,5,NA)
bad<-is.na(x)
bad
x[!bad]
y<-('a','b',NA,'c',NA,'d',NA)
y<-c('a','b',NA,'c',NA,'d',NA)
good<-complete.cases(x,y)
good
y<-c('a','b',NA,'c',NA,'d','f')
good<-complete.cases(x,y)
good
x[good]
y[good]
airquality[1:6,]
airquality[good]
good<-complete.cases(airquality)
airquality[good]
airquality[good,]
airquality[good,][1:6,]
x<-1:3;y<-6:9
x+y
y+x
x<-1:3;y<-6:8
y+x
x<-matrix(1:4,2,2);y<-matrix(10:13,2,2)
x*y
q()
install.packages("sand")
install.packages("knitr")
install.packages("ergm")
library(datasets)
head(airquality)
str(airqualit)
str(airquality)
s<-split(airquality,airquality$month)
s<-split(airquality,airquality$Month)
str(s)
x<c('a','b','c','d')
x<-c('a','b','c','d')
for (i in 1:4){}
for (i in 1:4){print(x[i])}
for (i in seq_along(x)){print(x[i])}
seq_along(x)
for letter in x {print letter}
for letter in x {print (letter)}
for (letter in x) {print (letter)}
print(i+1)
print(x[i+1])
print(x[i-1])
for (i in 1:4)  print(x[i])
print(x[i-1])
z<-Z-1
}
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
} else
} else{
z<-Z-1
z<-5
while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-Z+1
} else{
z<-Z-1
}
}
z<-5
while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-Z+1
} else{
z<-Z-1
}
}
z <- 5 while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-Z+1
} else{
z<-Z-1
}
}
z <- 5
while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-Z+1
} else{
z<-Z-1
}
}
z <- 5
while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-Z+1
} else{
z<-Z-1
}
}
z <- 5
while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-Z+1
} else{
z<-Z-1
}
}
z <- 5
while(z>=3 && z<=10){
print(z)
coin<-rbinom(1,1,0.5)
if (coin==1){
z<-z+1
} else{
z<-z-1
}
}
df<-data.frame(social=c(social.opt,social.btw),socialR=c(socialr.opt,socialr.btw),task=c(task.opt,task.btw),taskr=c(taskr.opt,taskr.btw))
socialr.opt<-assortativity.nominal(m182.social.rand,types=membership(m182.opt))
N<-100
x<-rnorm(N)+1;y<-rnorm(N)+1;dat<-data.frame(x,y)
x<-rnorm(N)+5;y<-rnorm(N)+1;dat<-data.frame(dat,data.frame(x,y))
x<-rnorm(N)+1;y<-rnorm(N)+5;dat<-data.frame(dat,data.frame(x,y))
dat
ob<-kmeans(x, 3, iter.max = 10, nstart = 1,algorithm="Hartigan-Wong", trace=FALSE)
fitted(ob, method = "centers" )
ob
cont3 <- read.graph("3continent_Asia_Oceania_Africa.gml",format="gml")
library(sand)
cont3 <- read.graph("3continent_Asia_Oceania_Africa.gml",format="gml")
cont3 <- read.graph("3continent_Asia_Oceania_Africa.gml",format="gml")
cont3 <- read.graph("3continent_Asia_Oceania_Africa.gml",format="gml")
library(network)
library(lattice)
library(latticeExtra)
library(intergraph)
library(ergm)
library(sand)
library(sand)
library(corrplot)
library(ngram)
# Loading the data
# Set the path correctly
setwd("C:/Users/TG/Documents/495/globalflightsnetwork/FinalProject")
# Load the edges
project.citiesToCities <- read.csv("C2C-E1.csv", head=TRUE, sep=",")
project.citiesToCitiesPass <- read.csv("C2CP-E1.csv", head=TRUE, sep=",")
# Load the attributes
project.citiesToCitiesVertex <- read.csv("C2C-V2.csv", head=TRUE, sep=",")
project.citiesToCitiesPassVertex <- read.csv("C2CP-V1.csv", head=TRUE, sep=",")
#Cities to cities network(Routes and distance)
citiesToCities.edge <- data.frame(project.citiesToCities$departure.city,
project.citiesToCities$arrival.city,
project.citiesToCities$number.of.routes,
project.citiesToCities$distance)
citiesToCities.net <- graph.data.frame(citiesToCities.edge, directed=TRUE, vertices=project.citiesToCitiesVertex)
assortativity.nominal (citiesToCities.net, types=project.citiesToCitiesVertex$Continent, directed = TRUE)
citiesToCities.net.opt<-optimal.community(citiesToCities.net)
